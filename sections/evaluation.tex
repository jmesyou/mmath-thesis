\chapter{Evaluation}

In this chapter, we will evaluate and discuss the performance of our polymorphic interpreter on two benchmarks.
We use an existing set of benchmarks from \cite{scala:miniboxing} as they exercise many features of the Scala runtime that require specialization to perform optimally.
We will evaluate performance of these benchmarks on the monomorphic interpreter as well as Scala bytecode on GraalVM as points of comparison for relative performance.
Finally, we will discuss the results of the benchmarks.

\section{Benchmarks}
\begin{figure}[!htb]
	\begin{minted}{scala}
	class ArrayBuffer[T] {
		protected def initialSize: Int = 16
		var size0 = 0
		var array: Array[T] = newArray[T](Math.max(initialSize, 1))
		
		def length: Int = size0
		
		private def get(i: Int): T = array(i)
		private def set(i: Int, elem: T): Unit = array(i) = elem
		
		def contains(elem: T): Boolean = {
			var i = 0
			while (i < size0) {
				if (array(i) == elem) return true
				i += 1
			}
			false
		}
		
		def reverse(): Unit = {
			var pos = 0
			while (pos * 2 < size0) {
				swap(pos, size0 - pos - 1) // swaps two elements in the array
				pos += 1
			}
		}
		
		def append(elem: T): Unit = {
			val newSize0 = size0 + 1
			ensureSize(newSize0)
			set(size0, elem)
			size0 = newSize0
		}
		
		// Ensure that the internal array has at least `n` cells. 
		def ensureSize(n: Int): Unit = {
			val arrayLength: Long = array.length // Use a Long to prevent overflows
			if (n > arrayLength) {
				var newSize: Long = arrayLength * 2
				while (n > newSize)
					newSize = newSize * 2
				// Clamp newSize to Int.MaxValue
				if (newSize > lang.Int.MaxValue) newSize = lang.Int.MaxValue
				
				val resized = newArray[T](newSize.toInt)
				var i = 0
				while (i < size0) {
					resized(i) = get(i)
					i += 1
				}
				array = resized
			}
		}
	\end{minted}
	\caption{Code of the \scalainline{ArrayBuffer} benchmark.}
	\label{example:arraybuffer-benchmark}
\end{figure}

In this section, we will introduce an additional program on top of our running example for benchmarking.
We will also summarize the motivations from \cite{scala:miniboxing} for the selection of these benchmarks.

\section{Methodology}

Performance measurements of a just-in-time compiled programs are an infamous issue\cite{java:performance-analysis}\cite{java:statistically-rigor-performance-analysis}.
Many non-deterministic effects, such as speculative optimization, garbage collection, thread scheduling to name a few, affect the performance of programs executing on the Java Virtual Machine.
As result, the JVM must be \textit{warmed up} prior to measure of program performance 
\section{Experimental Results}

\begin{figure}
	\centering
	\includesvg[width=\textwidth]{data/ArrayBuffer.Append.svg}
	\caption{Benchmark results for \scalainline{ArrayBuffer.append}.}
\end{figure}

\begin{figure}
	\centering
	\includesvg[width=\textwidth]{data/ArrayBuffer.Contains.svg}
	\caption{Benchmark results for \scalainline{ArrayBuffer.contains}.}
\end{figure}

\begin{figure}
	\centering
	\includesvg[width=\textwidth]{data/ArrayBuffer.Reverse.svg}
	\caption{Benchmark results for \scalainline{ArrayBuffer.reverse}.}
\end{figure}

\begin{figure}
	\centering
	\includesvg[width=\textwidth]{data/List.Append.svg}
	\caption{Benchmark results for \scalainline{List.append}.}
\end{figure}

\begin{figure}
	\centering
	\includesvg[width=\textwidth]{data/List.Contains.svg}
	\caption{Benchmark results for \scalainline{List.contains}.}
\end{figure}

\begin{figure}
	\centering
	\includesvg[width=\textwidth]{data/List.Hashcode.svg}
	\caption{Benchmark results for \scalainline{List.hashCode}.}
\end{figure}