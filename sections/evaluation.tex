\chapter{Evaluation}

\begin{figure}[!htb]
	\begin{minted}{scala}
	class ArrayBuffer[T] {
		protected def initialSize: Int = 16
		var size0 = 0
		var array: Array[T] = newArray[T](Math.max(initialSize, 1))
		
		def length: Int = size0
		
		private def get(i: Int): T = array(i)
		private def set(i: Int, elem: T): Unit = array(i) = elem
		
		def contains(elem: T): Boolean = {
			var i = 0
			while (i < size0) {
				if (array(i) == elem)
				return true
				i += 1
			}
			false
		}
		
		def reverse(): Unit = {
			var pos = 0
			while (pos * 2 < size0) {
				val tmp1: T = array(pos)
				val tmp2: T = get(size0 - pos - 1)
				set(pos, tmp2)
				set(size0 - pos - 1, tmp1)
				pos += 1
			}
		}
		
		def append(elem: T): Unit = {
			val newSize0 = size0 + 1
			ensureSize(newSize0)
			set(size0, elem)
			size0 = newSize0
		}
		
		// Ensure that the internal array has at least `n` cells. 
		def ensureSize(n: Int): Unit = {
			// Use a Long to prevent overflows
			val arrayLength: Long = array.length 
			if (n > arrayLength) {
				var newSize: Long = arrayLength * 2
				while (n > newSize)
					newSize = newSize * 2
				// Clamp newSize to Int.MaxValue
				if (newSize > lang.Int.MaxValue) newSize = lang.Int.MaxValue
				
				val resized = newArray[T](newSize.toInt)
				var i = 0
				while (i < size0) {
					resized(i) = get(i)
					i += 1
				}
				array = resized
			}
		}
		// Swap two elements of this array, omitted for brevity
		def swap(a: Int, b: Int): Unit = ??? 
	\end{minted}
	\caption{Code of the \scalainline{ArrayBuffer} benchmark.}
	\label{example:arraybuffer-benchmark}
\end{figure}
