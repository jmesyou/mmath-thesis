\chapter{Implementation}
\label{chapter:implementation}
% \epigraph{The best presents don't come in boxes.}{Bill Watterson}
% \epigraph{Typing is no substitute for thinking.}{Dartmouth Basic manual, 1964}

This chapter is divided into two parts.
The first half of this chapter will describe the methods used to execute TASTy in a Truffle interpreter.
In particular, we will cover how to tranform the semantics of TASTy to Truffle AST nodes.
The second half of this chapter covers the techniques we will use to eliminate autoboxing Truffle itself is unable to eliminate. 

\section{Execution}

Scala programs in \acrshort{tasty} format are unsuitable for execution in a Truffle interpreter. 
Programs in must be parsed and transformed into an executable representation in \textsc{TastyTruffle}. 
As TASTy represents a Scala program close to its equivalent source representation, canonicalization compiler passes (see appendix \ref{appendix:dotty-phases}) that would otherwise normalize the IR are not present. 
Instead, we implement TastyTruffle IR to represent a canonicalized executable intermediate representation which can be specialized on demand. 

In the following sections, we will describe the individual types of TASTy nodes and why some are directly unsuitable for execution and how to simplify their semantics for execution.
We will begin with a explanation of how data is encoded and defined in TASTy.


\subsection{Generating Frame Slots from \texttt{ValDef} trees} 

The \scalainline{ValDef} tree is a multi-purpose node which represents value definitions in many contexts.
This section will only cover the \scalainline{ValDef} tree in the context of local variables.
Sections \ref{impl:subsection:defdef} and \ref{impl:subsection:classdef} will cover the remaining contexts where \scalainline{ValDef} trees appear.

Local variables are variables which are bound to a \textit{scope}. 
A scope represents the lifetime in which a variable can refer to an entity. 
Similarly, uses of variables are only valid when used under the appropriate scope. 
Local variables and their use sites are represented in intermediate representations through a myriad of methods. 
In abstract syntax trees, local variables and their used are represented as nodes \textit{dominated} by their scopes (which are themselves nodes). 
Unlike more simplified \acrshort{ir}, abstract syntax trees do not encode any data dependence between definitions and uses\cite{ssa}. 
In order to execute the tree, name binding must be resolved when ???

In \acrshort{tasty}, a local variable is represented by the \scalainline{ValDef} tree node:

\begin{figure}[H]
	\begin{minted}{scala}
		case class ValDef(name: String, tpt: TypeTree, rhs: Option[Term]) extends Tree 
	\end{minted}
	\caption{Simplified \scalainline{ValDef} tree}
\end{figure}

The \scalainline{ValDef} tree represents the site of a local variable declaration when the node is dominated by a \scalainline{Block} node. 
A \scalainline{ValDef} contains the simple, unqualified name of the declaration, the type as represented in the source program and the intializer. 
When a \scalainline{ValDef} is dominated by a \scalainline{Block}, the initializer will always be non-empty.

Truffle specializes local variable access based on the variable's type during partial evaluation\cite{truffle:partial-eval}. 
To eliminate the need to specialize read and writes of variables where types are monomorphic and statically refer to a primitive type, the primitive frame slot kind is matched in the frame descriptor. 
In all other cases, including when the type is not resolvable through a single type parameter, e.g. \scalainline{val x: T}, we assign the frame slot the \scalainline{Object} frame slot kind.
We will defer discussion of variable declarations which have polymorphic types that cannot be resolved statically until section \ref{implementation:specialization}.

\subsection{Converting the \texttt{DefDef} tree into a Truffle Root Node}
\label{impl:subsection:defdef}

In this section, we describe the conversion of a \scalainline{DefDef} tree to \textit{root nodes}
Root nodes represent the root of an executable Truffle AST.
In this case, root nodes represent methods.
Each root node has a corresponding \textit{call target}, which is used for invocation.
A root node is automatically instrumented\cite{profiling:atom} to profile its number of invocations. 

\begin{figure}[!htb]
	\begin{minted}{scala}
	abstract class RootNode(desc: FrameDescriptor) {
		def execute(frame: Frame): Object
	}
	\end{minted}
	\caption{Pseudocode of a root node.}
	\label{example:root-node}
\end{figure}

Figure \ref{example:root-node} gives a simplified implementation of a root node.
Each root node in Truffle has a \textit{frame descriptor} and execution semantics.
A frame descriptor describes the guest language variables which are in the scope of the root node during execution.
The abstract \javainline{execute} method when combined with a \textit{frame} represents the execution behaviour of a root node.
A frame consists of arguments supplied during invocation and local variable definitions in the body of the method.
A guest language must subclass and implement its own root node in order to implement function invocation.
In this section, we will describe the necessary transformations to create and invoke a root node from a \scalainline{DefDef} method definition.

\begin{figure}[!htb]
	\begin{minted}{scala}
	class DefDef(_: String, params: List[ParamClause], _: TypeTree, rhs: Option[Term]) extends Definition	
	\end{minted}
	\caption{Defintion of a \texttt{DefDef} tree with names of less important members replaced with \texttt{\_}}
	\label{recall:defdef}
\end{figure}

A further simplified definition of a \scalainline{DefDef} tree is provided in figure \ref{recall:defdef}.
In this section, we focus on two members of a \scalainline{DefDef} trees.
The parameters of a \scalainline{DefDef} tree are given by the \scalainline{params} field.
In practice, the type of a \scalainline{ParamClause} is an alias for the union type \scalainline{TypeParams {|} TermParams}, so we omit its definition.
A \scalainline{DefDef} tree will have a parameter section for type parameters when they are polymorphic.
\scalainline{DefDef} trees may optionally have a body defined in the \scalainline{rhs} field.
When trees do not have a body defined, they are abstract method definitions and do not have corresponding root node in Truffle.
We will only consider non-abstract method definitions which have a body (a term) defined to be executable.
We will cover the conversion of terms in detail after section \ref{impl:subsection:classdef}

Normally after type erasure, only the term parameter section of a method definition is retained.
In this thesis, we \textit{reify} type parameters to be treated in the same manner as term parameters.
Each parameter declaration will have a corresponding frame slot in its parent frame descriptor. 
A frame slot references a unique frame value in the context of a root node.
Truffle permits each frame slot in a frame descriptor be described by a \textit{frame slot kind}.
At the time of writing, a frame slot kind can be implemented as:

\begin{figure}[!htb]
	\begin{minted}{scala}
	object FrameSlotKind extends Enumeration {
		type FrameSlotKind = Value
		val Object, Long, Int, Double, Float, Boolean, Byte = Value
	}
	\end{minted}
	\caption{Simplified implementation of \scalainline{FrameSlotKind}}
\end{figure}

There is a corresponding frame slot kind for reference types and each \acrshort{jvm} primitive type. 
We determine the frame slot kind of a type using the following method:

\begin{figure}[!htb]
	\begin{minted}{scala}
	def getFrameSlotKind(tpe: Type): Option[FrameSlotKind] = 
		if (tpe.isMonomorphic && tpe.isPrimitive) 
			Some(primitiveSlotKindOf(tpe))
		else if (tpe.isParameter) 
			None
		else 
			Some(FrameSlotKind.Object)
	\end{minted}
	\caption{Pseudocode for determining the frame slot kind of a type.}
\end{figure}

Some text 

\begin{figure}
	\begin{minted}{scala}
	import CompilerDirectives.castExact 
			
	def execute(frame: VirtualFrame): Object = {
		copyArgumentsToFrame(frame)
		rhs.execute()
	}	
	def copyArgumentsToFrame(frame: VirtualFrame): Unit = {
		val args = frame.getArguments
		val params = getParameters
		for ((param, arg) <- params zip args) {
			param.getFrameSlotKind match {
				case FrameSlotKind.Boolean =>
					frame.setBoolean(param.getFrameIndex, arg.asInstanceOf[Boolean])
				case FrameSlotKind.Int =>
					frame.setInt(param.getFrameIndex, arg.asInstanceOf[Int])
				case FrameSlotKind.Long =>
					frame.setLong(param.getFrameIndex, arg.asInstanceOf[Long])
				case FrameSlotKind.Double =>
					frame.setDouble(param.getFrameIndex, arg.asInstanceOf[Double])
				case _ =>
					if (param.getType.isArray)
						frame.setObject(param.getFrameIndex, castExact(arg, param.getType))
					else
						frame.setObject(param.getFrameIndex, arg)
			}
		}
	}	
	\end{minted}

\caption{Pseudocode for }
\end{figure}

\subsection{Deriving Shapes from the \texttt{ClassDef} Tree}
\label{impl:subsection:classdef}

The storage layout of an object in a Truffle interpreter is managed by a \textit{Shape}.

\begin{figure}[!htb]
	\begin{minted}{scala}
	private ClassShape(
		symbol:  Symbol,
		parents: Array[Symbol],
		fields:  Array[Field] ,
		methods: Map[MethodSignature, RootCallTarget]
		vtable:  Map[Signature, Symbol]
	)
	\end{minted}
	\caption{Simplified implementation of a shape.}
\end{figure}

\subsection{Data mutation with the \texttt{Assign} tree}

\subsection{Initializing Objects with the \texttt{New} Tree}

\subsubsection{Escape Analysis}

Escape analysis\cite{escape-analysis} reasons about the dynamic scope of object allocations. 
Compiler implementations often exploit the observations of escape analysis to enable optimizations such:

\begin{description}
	\item[Region Allocation\cite{java:escape-analysis}\cite{tofte:region-memory}] The substitution of heap allocations with stack allocations to eliminate unnecessary garbage collection.
	\item[Scalar Replacement\cite{java:escape-analysis-optimizations}] The complete elimination of an object allocation, where the fields of the replaced object are substituted by local variables.
\end{description}

GraalVM employs \textit{Partial Escape Analysis}\cite{java:partial-escape-analysis}, a path-sensitive variant of escape analysis which is particularly effective when combined with optimizations described above as well other compiler optimization such as inlining. 
Truffle offers guest language implementations the \scalainline{VirtualFrame} abstraction to allow guest language semantics to take advantage of partial escape analysis and subsequent optimizations.

\subsection{The \texttt{Block} tree}

\subsection{The \texttt{While} tree}

\subsection{The \texttt{Select} tree}

% Intro

\subsection{Disambiguating \texttt{Apply} trees}

The \scalainline{Apply} treee
Method invocations exists in multiple forms because tree canocalization happens immediately after the TASTy picking phase in the compilation pipeline.
The result is that TASTy trees retain some syntactic elements from their Scala sources. 
For example, Truffle provides two abstractions for call nodes, the \textit{direct call node} is used when the call target can be statically resolved. 
In TASTy, this includes the set of methods with private or final modifiers\cite{java:lang-spec} and class constructors. 
Otherwise, the \textit{indirect call node} is used for calls which have dynamically resolved call targets. 
\textsc{TastyTruffle} uses a singular call node implementation for both monomorphic and polymorhic calls. 
we utilize a polymorphic inline cache\cite{self:polymorphic-inline-caches} to eliminate the overhead of resolving polymorphic calls for \acrshort{jit} compilation. 
Figure \ref{implementation:poly-cache-call-node} shows a simplified Truffle call node in \textsc{TastyTruffle} which implements a polymorphic inline cache.

\begin{figure}[!htb]
	\begin{minted}{scala}
	class ApplyNode(sig: Signature, receiver: TermNode, args: Array[TermNode]) extends TermNode {
		
		final val INLINE_CACHE_SIZE: Int = 5;
		
		@Specialization(guards = "inst.type == tpe", limit = "INLINE_CACHE_SIZE")
		def cached(
			frame: VirtualFrame,
			inst: ClassInstance,
			@Cached("inst.type") tpe: Type,
			@Cached("create(resolveCall(instance, sig)") callNode: DirectCallNode
		): Object = callNode.call(evalArgs(frame, inst));
		
		@Specialization(replaces = "cached")
		def virtual(
			frame: VirtualFrame,
			inst: ClassInstance,
			@Cached callNode: IndirectCallNode
		): Object = {
			val callTarget = resolveCall(instance, sig);
			callNode.call(callTarget, evalArgs(frame, inst))
		}
	}
	\end{minted}
	\caption{Simplified implementation of the call node with a polymorphic inline cache used in TastyTruffle.}
	\label{implementation:poly-cache-call-node}
\end{figure}

The Truffle \acrshort{dsl} emits a cache which is searched linearly based on the type of receiver. 
When the type of receiver has not been seen in the inline cache, an additional cache entry is generated and appended to the cache for the next call. 
The size of an polymorphic inline cache must be kept reasonable ???. 
The generated inline cache can be used to inline code and JIT optimized based on the type of the receiver seen at a call site. 


\begin{figure}[H]
	\centering
	\includegraphics[width=0.75\textwidth]{figures/tastytruffle-pic-example.png}
	\caption{A possible polymorphic inline cache for a \scalainline{List.contains} callsite.}
	\label{example:poly-cache-call-node}
\end{figure}

When the polymorphic inline cache is applied to a monomorphic call site, it simplifies to a single element inline cache\cite{smalltalk:inline-caches}. 
Because the type of the receiver at the call site remains stable, the cache look up of the call target based on the type always succeeds and the call site never fallbacks to using an indirect call node.


\subsubsection{Unary and Binary Expressions}

Unary and Binary operations in Scala are syntactic sugar for function invocation. 
For example, the following addition \scalainline{1 + 2} is desugared to \scalainline{1.+(2)}. 
That is, the binary operator \scalainline{+} is represented as the invocation of the instance function \scalainline{Int.+} on the receiver with value \scalainline{1} and type \scalainline{Int} with a single argument \scalainline{2}.
Normally in the Scala compilation pipeline, methods which operate on primtive types and have an underlying implementation on the JVM\cite{java:vm-spec}, e.g. in a bytecode instruction, are replaced by those instructions in compiled program bytecode. 
Similarly, TastyTruffle avoids implementing methods of primitive types with actual call semantcs as primitive operations are frequently used and simple to optimize as instrinsic implementations exist on many Java virtual machines.\cite{???}


\subsection{The \texttt{Ident} tree}

\section{Specialization}
\label{implementation:specialization}

\subsection{Specializing Object Layout with \texttt{Applied} type trees}

\begin{figure}[!htb]
	\begin{minted}{scala}
	trait PolymorphicTermNode extends TermNode {
		def resolveType: ClassType 
		override def execute(frame: VirtualFrame): Object = 
			throw new UnsupportOperationException("generic code cannot be executed!")
	}
	\end{minted}
	\caption{A placeholder node for polymorphic code in \textsc{TastyTruffle}}
\end{figure}

\begin{figure}
	\centering
	\begin{subfigure}[b]{0.4\textwidth}
		\centering
		\includegraphics[width=\textwidth]{figures/dot/List.head.boxed.TruffleTier.png}
		\caption{Graal IR of \scalainline{Cons.head} focused on field access of \scalainline{head0}}
		\label{graalir:cons-head-boxed}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{figures/dot/List.contains.boxed.TruffleTier.png}
		\caption{Graal IR of \scalainline{Cons.head} after being inlined into \scalainline{Cons.contains}}
		\label{graalir:cons-contains-head-focus-boxed}
	\end{subfigure}
	\hfill
\end{figure}

\subsection{Specializing Call Sites with \texttt{TypeApply} trees}

Generic methods in Scala can be polymorphic under class type parameters, method type parameters, or both. 
In the latter two cases, polymorphic methods contain additional reified type parameters. 
In addition to the polymorphic terms present in the method body discussed in the previous section, the type of method term parameters may be polymorphic. 
The following components of a generic method must specialized:

\begin{itemize}
	\item Polymorphic method parameters.
	\item Polymorphic terms inside the method body.
\end{itemize}


\subsubsection*{Method Parameters}

\subsubsection*{Typed Dispatch Chains}

Dispatch chains\cite{???}

\begin{figure}[H]
	\begin{minted}{scala}
	class TypeDispatchNode(parent: RootNode) extends TermNode {
		
		type TypeArguments: Array[Type]
		@CompilerDirectives.CompilationFinal
		var cache: Map[TypeArguments, DirectCallNode]
		
		override def execute(frame: VirtualFrame): Object = {
			val types: TypeArguments = resolveTypeParameters(frame)
			dispatch(frame, args);
		}
		
		def dispatch(frame: VirtualFrame, types: TypeArguments): Object = cache.get(types) match {
			case Some(callNode) => callNode.call(frame.getArguments)
			case None           => createAndDispatch(frame, types)
		}
		
		def createAndDispatch(frame: VirtualFrame, types: TypeArguments): Object = {
			CompilerDirectives.transferToInterpreterAndInvalidate()
			val specialization = parent.specialize(types)
			val callNode = DirectCallNode.create(specialization)
			cache = cache.updated(types, callNode)
			callNode.call(frame.getArguments)
		}
	}
	\end{minted}
\caption{Simplified implementation of generic dispatch node based on reified type arguments.}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.75\textwidth]{figures/tastytruffle-type-dispatch-chain.png}
	\caption{The typed dispatch chain for a \scalainline{List.contains} call site }
\end{figure}

\subsubsection*{Code Duplication}

\subsubsection*{Partial Evaluation}

\subsection{Specializing Terms}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.4\textwidth]{figures/dot/List.contains.boxed-param-read.TruffleTier.png}
	\caption{Graal IR of \scalainline{List.head} after field read of \scalainline{head0} is specialized.}
	\label{graalir:cons-contains-param-read}
\end{figure}


\begin{figure}
	\centering
	\begin{subfigure}[b]{0.4\textwidth}
		\centering
		\includegraphics[width=\textwidth]{figures/dot/List.head.specialized.TruffleTier.png}
		\caption{Graal IR of \scalainline{List.head} after field read of \scalainline{head0} is specialized.}
		\label{graalir:cons-head-specialized}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.4\textwidth}
		\centering
		\includegraphics[width=\textwidth]{figures/dot/List.contains.specialized.TruffleTier.png}
		\caption{Graal IR of \scalainline{Cons.head} after being inlined into \scalainline{Cons.contains}}
		\label{graalir:cons-contains-head-focus-specialized}
	\end{subfigure}
	\hfill
\end{figure}


The basic polymorphic unit of code in Scala are terms whose types are derived directly from a type parameter \mintinline{scala}|T| or indirectly from a type constructor such as \mintinline{scala}|Array[T]|.
Polymorphic terms can be divided into the following categories:

\subsubsection*{Polymorphic local access}
\subsubsection*{Polymorphic field access}
\subsubsection*{Polymorphic method call}
\subsubsection*{Polymorphic instantiation}

