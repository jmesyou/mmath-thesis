\chapter{Background}

In this chapter, we will provide an introduction to the Scala programming language. 
We will showcase a running example that we will use for the remainder of this thesis which exhibits features commonly present in Scala programs. 
We will describe \acrfull{tasty}, an intermediate storage format used for separate compilation\cite{???} of Scala programs. 
We will introduce a critical transformation, type erasure, which alters Scala programs so that they may executable on their default platform the \acrfull{jvm}. 
We will detail GraalVM \acrfull{jit} compiler infrastructure, an alternative JVM implementation which we use to implement a runtime for Scala in this thesis.

\section{Scala}

Scala\cite{scala:overview} is a objected-oriented, generic and statically typed programming language.
Scala uses a \textit{pure} object-oriected programming model\cite{smalltalk:design} and addresses many of the shortcomings\cite{go4:design-patterns} in other object-oriented programming languages.
Scala can be still considered \textit{Java-like} because of the interoperability between Java and Scala programs.
Programs in Scala may contain generic definitions, allowing Scala programs to composable and reusable\cite{scala:origins}.
We describe the programming paradigms present in Scala in detail:

\begin{description}
	\item[Object-oriented] 
	Every value in Scala is an object and every operation is method invocation on an object. 
	Every object in Scala is an instance of a \textit{class} and their type is determined by their class.
	Classes\cite{simula:classes} are a mechanism for defining state and behaviour for a group of objects.	
	
	\item[Generic] 
	Classes in Scala may contain \textit{type parameters} and such classes can be considered \textit{polymorphic}\cite{strachey:fundamental-concepts}.
	Polymorphic classes may define behavior independent of their state, allowing them to be reused extensively for multiple types of data.
	
	\item[Statically typed] 
	Static typing is a discipline where the type information about a program is known \textit{before} it is executed.
	In order for a Scala program to compile successfully, it must be \textit{well-type}.
	For our purposes, computation should always produce a value which has a type matching the type declared by the programmer to be considered well-typed.
	Classes are the primary syntactical mechanism for declaring types in Scala. 
	The properties of classes such as state, in the form of fields, and behaviour, in the form of methods, must be well-typed.
	Similarly, the uses of these properties in other classes must also be well-typed. 
\end{description}

\section{Case Study: A List in Scala}

In this section, we will introduce the running example that will be used for the remainder of this thesis and our motivations for its selection.
Figures \ref{example:list-def}, \ref{example:cons-impl} and \ref{example:nil-impl} contain an abstract singly-linked list class and its two concrete subclass implementations. 
This set of \scalainline{List} implementations represent probable real-world use cases as they are a scaled down and simplified version of the list implementation present in the Scala collections library.
The \scalainline{List} definition from the collections library is available by default to all Scala programs.

\begin{figure}[!htb]
	\begin{minted}{scala}
	abstract class List[+T] {
		def head: T
		def tail: List[T]
		def length: Int
		def isEmpty: Boolean = length == 0
		def contains[T1 >: T](elem: T1): Boolean
	}
	\end{minted}
	\caption{Definition of \texttt{List} class}
	\label{example:list-def}
\end{figure}

Figure \ref{example:list-def} is an example which showcases the paradigms discussed in the previous section that are also commonly present real-world Scala programs.
Implementations which derive abstract the \scalainline{List} class will demonstrate \textit{class inheritance}.
The \scalainline{List} class contains a mixture of polymorphic and non-polymorphic methods to showcase type specialization
The \scalainline{head} method is class-polymorphic in that its type is derived from a class parameter and becomes specialized when the class is specialized.
The \scalainline{contains} method is method-polymorphic and must be specialized after the class is specialized.

\begin{figure}[!htb]
	\begin{minted}{scala}
	case class Cons[+T](head: T, tail: List[T]) extends List[T] {
		override def length: Int = 1 + tail.length
		
		override def contains[T1 >: T](elem: T1): Boolean = {
			var these: List[T] = this
			while (!these.isEmpty) 
			if (these.head == elem) return true
			else these = these.tail
			false
		}
			
		override def hashCode(): Int = {
			var these: List[T] = this
			var hashCode: Int = 0
			while (!these.isEmpty) {
				val headHash = these.head.## // Compute hashcode
				if (these.tail.isEmpty) hashCode = hashCode | headHash
				else hashCode = hashCode | headHash >> 8
				these = these.tail
			}
			hashCode
		}
	}
	\end{minted}
	\caption{Implementation of \texttt{Cons} class}
	\label{example:cons-impl}
\end{figure}

Figure \ref{example:cons-impl} contains the implementation of a list node.
The \scalainline{Cons} implementation contains two polymorphic fields, \scalainline{head} and \scalainline{tail}.
For specialization, how the \scalainline{head} field fits into the storage layout of a \scalainline{Cons} instance may differ between a \scalainline{Cons[Int]} and a \scalainline{Cons[String]}.
On the other hand, the \scalainline{tail} field does not have to differ between instances of \scalainline{Cons[Int]} and \scalainline{Cons[String]}.

\begin{figure}[!htb]
	\begin{minted}{scala}
	case object Nil extends List[Nothing] {
		override def head: Nothing = throw new NoSuchElementException("head of empty list")
		override def tail: Nothing = throw new UnsupportedOperationException("tail of empty list")
		override def length: Int = 0
		override def contains[T1 >: Nothing](elem: T1): Boolean = false
		override def hashCode(): Int = 0
	}
	\end{minted}
	\caption{Implementation of \texttt{Nil} class}
	\label{example:nil-impl}
\end{figure}

Figure \ref{example:nil-impl} contains the implementation of the empty list. 
We provide the implementation of this class for completeness.


\section{Typed Abstract Syntax Trees}

An \acrfull{ir} is a structural abstraction representing a program during compilation or execution. 
Intermediate representations are more suitable for reasoning about a program than program source code. 
\acrshort{ir} can be used for compilation\cite{llvm}, optimization\cite{llvm}\cite{ssa}, or execution\cite{java:vm-spec}\cite{clr:spec}.

\acrfull{tasty} is a high-level \acrfull{ir} which is produced and emitted after type checking phase of the Scala compiler (see appendix \ref{appendix:dotty-phases}).
Figure \ref{system:tasty} gives an overview of TASTy generation in the context of the Scala compilation pipeline, note that TASTy is only generated for Scala program sources.
TASTy is a well-typed variation of an \acrfull{ast}, a commonly used intermediate representation close to the program source representation.
TASty can be considered a \textit{complete} IR of a Scala program before compilation, unlike the other intermediate representations we will examine throughout this thesis.
A complete IR is able to capture all information of the original Scala source program, we will expand on why this is significant in section \ref{background:type-erasure}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\textwidth]{figures/scala-pipeline.png}
	\caption{TASTy in the context of the Scala compilation pipeline.}
	\label{system:tasty}
\end{figure}

In this thesis, we will use a limited subset of TASTy which is sufficient to represent the program given in figures \ref{example:list-def} and \ref{example:list-impl}.
The TASTy trees used in this thesis can be divided into categories, definitions, terms, and types. 
We give the pseudo implementations of these trees in figures \ref{tasty:defs}, \ref{tasty:terms}, and \ref{tasty:types}.

\subsection{Definitions}

\begin{figure}[!htb]
	\begin{minted}{scala}
	// Tree representing code written in the source
	trait Tree {
		def symbol: Symbol
	}                         
	trait Statement extends Tree       // Tree representing a statement in the source code
	trait Definition extends Statement // Tree representing a definition in the source code.
		
	// Tree representing a class definition.
	case class ClassDef(
		name:        String,
		constructor: DefDef, 
		parents:     List[Tree], 
		self:        Option[ValDef], 
		body:        List[Statement]
	) extends Definition
	// Tree representing a method definition in the source code
	case class DefDef(
		name:      String, 
		params:    List[ParamClause], 
		returnTpt: TypeTree, 
		rhs:       Option[Term]
	) extends Definition
	// Tree representing a value definition in the source code.
	case class ValDef(name: String, tpt: TypeTree, rhs: Option[Term]) extends Definition
	// Tree representing a type (parameter or member) definition in the source code
	case class TypeDef(name: String, rhs: Tree) extends Definition
	\end{minted} 
	\caption{Pseudocode class definitions for a subset of TASTy trees.}
	\label{tasty:defs}
\end{figure}

A Scala program consists of top level class definition which themselves contain statements.
Statements either represent a declaration inside a class, such as a method definition, or executable code, which we discuss in section \ref{section:tasty:terms}.
Figure \ref{tasty:defs} provides the pseudo implementations of all definitions in our subset of TASTy.
Every tree has a symbol, which is a unique reference to a definition.
For the use cases in this thesis, most definitions can be translated and be represented by a corresponding implementation in Truffle.
A \scalainline{ClassDef} represents a top level class definition.
A \scalainline{DefDef} tree is the definition of a method inside a class definition.
The trees defined here can be used to represent more complex object-oriented and functional abstractions such as nested classes or closures, they are beyond the scope of this thesis.

Figure \ref{tasty:list} is the TASTy structure of the \scalainline{List} class given in figure \ref{example:list-def}. 
Recall that \scalainline{ClassDef} trees has four structural components, the constructor, the list of parent class definitions, the self type, and the body of the definition.
In this thesis, we will not discuss the self type as it is an abstraction for composition\cite{gilad:mixins}\cite{scala:calculus} and is not relevant for execution.
In the Scala programs presented in this thesis, the list of parents in a class definition can be assumed to always be a singleton.
Note that while the abstract \scalainline{List} class did not explicitly declare a constructor, the compiler autogenerates and inserts the appropriate constructor implementation before emitting TASTy.
Since \scalainline{List} is polymorphic, it contains an inner type definition of its sole type parameter.
This distinction is what makes TASTy a complete IR when compared to the other intermediate representations we will describe later in this chapter.

\begin{figure}[!htb]
	\begin{minted}{scala}
	ClassDef(
		// name 
		"List",
		// constructor
		DefDef("<init>", List(TypeParams(TypeDef("T", TypeBoundsTree(_, _)), TermParams(Nil)), _, None)),
		// parents
		List(Apply(Select(New(_, "<init>"), Nil))),
		// self
		None,
		// body
		List(
			TypeDef("T", TypeBoundsTree(_, _)),
			DefDef("head", Nil, TypeIdent("T"), None),
			DefDef("tail", Nil,Applied(TypeIdent("List"), List(TypeIdent("T"))),None),
			DefDef("length", Nil, TypeIdent("Int"), None),
			DefDef("isEmpty", Nil, TypeIdent("Boolean"), None),
			DefDef(
				"contains",
				List(
					TypeParams(TypeDef("T1", TypeBoundsTree(TypeIdent("T"), _))),
					TermParams(ValDef("elem", TypeIdent("T1"), None))
				),
				TypeIdent("Boolean"),
				None
			)
		)
	)
	\end{minted} 
	\caption{Tree structure for the definition of \texttt{List} . For brevity, we use \textbf{\texttt{\_}} to represent inferred\cite{ml:type-inference} type trees by the compiler.}
	\label{tasty:list}
\end{figure}

Similarly, \scalainline{DefDef} trees also retain their polymorphic properties.
The parameters section of a \scalainline{DefDef} tree is split into two halves.
The type parameter section preserves any polymorphic type parameters in the method definition.
The term parameter section contains the normal value paramers found in a method.
Term parameters may have types which are derived from the type parameter section.

\subsection{Terms}
\label{section:tasty:terms}

\begin{figure}[!htb]
	\begin{minted}{scala}
	// Tree representing an expression in the source code
	trait Term extends Statement {
		def tpe: Type
	}
	// Tree representing a reference to definition      
	trait Ref extends Term             
	
	// Tree representing an assignment lhs = rhs in the source code
	case class Assign(lhs: Term, rhs: Term) extends Term
	// Tree representing new in the source code
	case class New(tpt: TypeTree) extends Term
	// Tree representing a block `{ ... }` in the source code
	case class Block(statements: List[Statement], expr: Term) extends Term
	// Tree representing a while loop
	case class While(cond: Term, body: Term) extends Term
	// Tree representing a selection of definition with a given name on a given prefix
	case class Select(qualifier: Term, selector: String) extends Term 
	// Tree representing an application of arguments.
	case class Apply(applicator: Term, arguments: List[Term]) extends Term
	// Tree representing an application of type arguments
	case class TypeApply(fun: Term, args: List[TypeTree]) extends Term
	// Tree representing a reference to definition with a given name
	case class Ident(name: String) extends Ref 
	\end{minted} 
	\caption{Pseudocode class definitions for a subset of TASTy trees.}
	\label{tasty:terms}
\end{figure}

Figure \ref{tasty:terms} gives the implementation for terms in our subset of TASTy.
Terms represent an executable atom of code which return a value.
Terms can be thought of as a representation that is analogous to expressions from the abstract syntax trees commonly used for other imperative programming languages.
Our term tree subset of TASTy represents a basic language with support for simple imperative programming with control flow constructs such as branching and loops.
A basic set of object-oriented features are also encapsulated in the tree definitions given above, these include object creation, instance method invocation, and instance field access.
This subset of TASTY is sufficient to represent the creation of polymorphic classes as well as the invocation of polymorphic methods to showcase the described in this thesis.

Terms in TASTy also retain their types after the type checking by the Scala compiler.
A type for a term describes the type of the value produced by the term.
Terms with no children, such as \scalainline{Ident} trees, are typed.  
For terms with children, their types are derived from those of their children trees.
In essence, types `flow' upwards from leaf nodes in TASTy to their parent terms until the root term.
We will describe types in detail in the following section.

\subsection{Types and Type Trees}

TASTy encodes Scala programs with two kinds of type information, types trees and types.
Type trees are a subset of trees which represent types as they are declared in Scala source code.
On the other hands, types are the canonical representation of type trees after type checking in the Scala compiler.
Multiple type trees may share the same underlying type.

\begin{figure}[!htb]
	\begin{minted}{scala}
	// Type tree representing a type written in the source
	trait TypeTree extends Tree {
		def tpe: Type
	}
	
	// Type tree representing a reference to definition with a given name
	case class TypeIdent(name: String) extends TypeTree 
	// Type tree representing a type application
	case class Applied(tpt: TypeTree, args: List[TypeTree | TypeBoundsTree]) extends TypeTree
	// Type tree representing a type bound written in the source
	case class TypeBoundsTree(lo: TypeTree, hi: TypeTree) extends TypeTree
	\end{minted} 
	\caption{Pseudocode class definitions for a subset of TASTy type trees.}
	\label{tasty:type-trees}
\end{figure}

Figure \ref{tasty:type-trees} gives the subset of type trees which we will use in this thesis.
For our purposes, there are only three ways to refer to types.
A \scalainline{TypeIdent} type tree is a reference to a type which is a \scalainline{ClassDef}.
An \scalainline{Applied} type tree represents type constructor, which accept type arguments and produce a new type.
For example, the \scalainline{Cons[T]} would be represented as an applied type tree, where \scalainline{Cons} would the constructor and \scalainline{T} would be the type argument.
A \scalainline{TypeBounds} tree represents the type expression \scalainline{Lo <: T <: Hi}, a constraint where \scalainline{T} must be a subtype of type \scalainline{Hi} and supertype of type \scalainline{Lo}.
In the context of this thesis, we can use subtype to mean \textit{subclass of} and supertype of to mean \textit{superclass of}.

\begin{figure}[!htb]
	\begin{minted}{scala}
	trait Type                           // A type, type constructors, type bounds
	trait NamedType extends Type         // Type of a reference to a type or term symbol
	case class TypeRef extends NamedType // Type of a reference to a type symbol
	case class AppliedType extends Type  // A higher kinded type applied to some types T[U]
	case class TypeBounds extends Type   // Type bounds
	\end{minted} 
	\caption{Pseudocode class definitions for a subset of TASTy type trees.}
	\label{tasty:types}
\end{figure}

Figure \ref{tasty:types} is set of types used in our subset of TASTy.
In most cases in our subset of TASTy, type trees have a corresponding type of the same name.
However, the \scalainline{NamedType} does not appear in type trees as they are predominantly used to type terms.
The \scalainline{TypeRef} type is a reference to a \scalainline{ClassDef} tree or a type paramter \scalainline{TypeDef}.

In the Scala compilation pipeline, TASTy is eventually simplified and transformed by the Scala compiler to produce Java bytecode. 
In chapter \ref{chapter:implementation}, We will go over each tree before such transformations and their relevance for execution in our interpeter .

\section{Java Bytecode}

Java bytecode is a portable and compact intermediate language and instruction set used by the Java Virtual Machine to execute programs.
Java bytecode can be considered similar to an assembly language, where programs are represented as sequences of atomic instructions which manipulate a stack or registers.
The type system in Java bytecode can describe primitive values such as \javainline{int} and references to objects such as \javainline{String}.
As bytecode is intended to be simple for execution, it is not possible to represent polymorphic programs fully in Java bytecode.

Types in TASTy are not immediately compatible with types available in Java bytecode.
Scala's type semantics must be eliminated from programs by the compiler before Java bytecode of the program can be emitted.
The resulting Java bytecode is considered an \textit{incomplete} IR of Scala source programs, as the type information found in the program source or inferred from compilation is no longer present.
This becomes a particular drawback for executing Scala programs on the JVM because speculative optimizations are unable to incorporate source level semantics.

\begin{figure}[!htb]
	\begin{minted}{scala}
	0:  aload_0
 	1:  astore_2
	2:  aload_2
	3:  invokevirtual #44 // List.isEmpty:()Z
	6:  ifne          30
	9:  aload_2
	10: invokevirtual #46 // List.head:()Ljava/lang/Object;
	13: aload_1
	14: invokestatic  #52 // Method scala/runtime/BoxesRunTime.equals:(Ljava/lang/Object;Ljava/lang/Object;)Z
	17: ifeq          22
	20: iconst_1
	21: ireturn
	22: aload_2
	23: invokevirtual #53 // List.tail:()LList;
	26: astore_2
	27: goto          2
	30: iconst_0
	31: ireturn
	\end{minted}
	\caption{Java bytecode of \texttt{Cons.contains}}
	\label{example:contains-bytecode}
\end{figure}

Figure \ref{example:contains-bytecode} is the Java bytecode of the \scalainline{contains} defined at line 4 in figure \ref{example:cons-impl}.
Typical control flow elements of Scala programs such as if terms and while terms have been converted into branch and jump instructions.
Notice that there are no polymorphic type parameters in the description of classes nor in the invocation of polymorphic methods present in the bytecode.
In particular, notice the equality comparison in line 7 of figure \ref{example:cons-impl} is actually a method invocation (line 14 in figure \ref{example:contains-bytecode}).
As the Scala compiler is unable to determine the type of a polymorphic type parameters during complilation time, it is unable to select a Java bytecode instruction which implements polymorphic comparison.
Instead, a bridge method part of the Scala standard library is responsible for handling polymorphic operations which operate on both reference and primitive types during runtime.
In the next section, we describe the process which transforms Scala programs to a reprensentation amenable for Java bytecode generation and the necessary additional runtime overhead associated with this transformation.

\section{Type Erasure}
\label{background:type-erasure}

Type erasure\cite{java:generics} is a transformation which converts polymorphic classes and methods in Scala to monomorphic classes and methods. 
This conversion is necessary because the JVM does not support polymorphic classes during runtime.
Erasure ensures that any given polymorphic class and method has a single representation in practice.
Type erasure is a crucial part of the Scala compilation which renders TASTy incomplete.
Figure \ref{example:erase-cons} shows the \scalainline{Cons} class after type erasure.

\begin{figure}[!htb]
	\begin{minted}{scala}
	case class Cons(head: Any, tail: List) extends List {
		override def length: Int = 1 + tail.length
			
		override def contains(elem: Any): Boolean = {
			var these: List = this
			while (!these.isEmpty) 
			if (these.head == elem) return true
			else these = these.tail
			false
		}
			
		override def hashCode(): Int = {
			var these: List = this
			var hashCode: Int = 0
			while (!these.isEmpty) {
				val headHash = these.head.##
				if (these.tail.isEmpty) hashCode ||= headHash
				else hashCode |= headHash >> 8
				these = these.tail	
			}
			hashCode
		}
	}		
	\end{minted}
	\caption{\scalainline{Cons} class after type erasure}
	\label{example:erase-cons}
\end{figure}

The polymorphic \scalainline{Cons} class has all type parameters in its class definition \textit{erased} and replaced by the \scalainline{Any} type.
The \scalainline{Any} type is a Scala platform-independent\cite{scala:overview} abstract type representing the super type of primitive and reference types.
In Java bytecode, the {Any} type resolves to the \scalainline{Object} type, the super type of all reference types on the JVM.

While type erasure simplifies classes for runtime, the Scala compiler must resolve the incompatibility of operations between primitives types and reference types on the JVM\cite{java:vm-spec},
The set of operations introduced by the compiler whenever a primitive value is accessed under a polymorphic context is known as \textit{autoboxing}\cite{java:autoboxing}. 
Autoboxing can be divided into two operations.
\textit{Boxing} occurs when a primitive value must be used where a generic value is expected.
\textit{Unboxing} occurs when a generic value must be used where a primitive value is expected.
Figure \ref{example:autoboxing} shows a simple example of inserted autoboxing operations when using the polymorphic \scalainline{Cons} class after type erasure.

\begin{figure}[!htb]
	\begin{minted}{scala}
	// Before type erasure 	
	val lst: List[Int] = Cons(1, Nil)
	val head: Int = lst.head
	// After type erasure
	val lst: List = Cons(box(1), Nil)
	val head: Int = unbox(lst.head) 
	\end{minted}
	\caption{Example of autoboxing introduced for a list}
	\label{example:autoboxing}
\end{figure}

The \scalainline{head0} field inside the \scalainline{Cons} class after erasure is no longer polymorphic and instead has the type \scalainline{Any}. 
The integer value of \scalainline{1} which is passed into the class constructor for the list is boxed and the primitive value is wrapped as a instance of its boxed class.
Similarly, when the \scalainline{head0} field of the instance is read and stored into a local variable, an unboxing operation occurs which extracts the primitive value out of its wrapper instance.
In the Scala collections library, a set of commonly used polymorphic data structures, autoboxing operations are frequent and necessary.
The computational overheads of autoboxing operations on programs which make substantial use of polymorphic collections, especially the Scala standard library, is significant\cite{scala:collections-optimization}.
The elimination of this overhead through optimizing autoboxing operations is one of the central goals of this thesis.

\section{GraalVM}

GraalVM\cite{java:graalvm} is an implementation of a JVM.
Traditionally, the JVM is responsible for the majority of the performance optimizations in Java programs\cite{java:hotspot} through \acrfull{jit} compilation.
JIT compilation is an adaptive optimization which occurs during program execution.
JIT compilation is concerned with optimizing and eliminating \textit{hotspots} or portions of the program which are the slowest.
JIT compilers\cite{java:sablevm}\cite{java:jikesrvm} employ a range of \textit{speculative} techniques to transform the program under optimization.
Speculative optimizations use information collected during program execution, otherwise known as \textit{profiling}. 
Assumptions are then made about gathered profiling data in order to generate high-performance native machine code.

While other implementations of Java virtuals machines were designed specifically for Java, GraalVM was designed from the onset to be \textit{language-independent}.
GraalVM can be divided into two components. 
The first is \textit{Truffle}, a framework for translating the semantics of a source language, also called a \textit{guest language}, to take advantage of the Graal infrastrucure.
The second is \textit{Graal}, a language-agnostic JIT compilation infrastructure which handles speculative optimizations and generation of high-performance machine code.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.5\textwidth]{figures/graalvm-pipeline.png}
	\caption{GraalVM overview\cite{graalvm:ir}.}
\end{figure}

This thesis makes substantial of both components of GraalVM to create a runtime for Scala programs using TASTy.
The runtime is able to incorporate source level information for speculative optimizations.


\subsection{Graal}

GraalVM incorporates an existing implementation of a JVM\cite{java:hotspot} for the actual execution of programs.
Graal is \textit{only} the general-purpose just-in-time compilation infrastructure which optimizes the programs to be executed.
Graal is general-purpose in that conducts analysis and optimization on the same intermediate representation, \textit{Graal IR}, regardless of the original source language.

Graal IR\cite{graalvm:ir}\footnote{Given the number of intermediate representations introduced thus far, we promise this is the last one} is an IR which is suitable for speculative optimizations while still retaining information from the Truffle guest language AST.
Graal IR is based on the \textit{sea of nodes} concept\cite{click:sea-of-nodes} and sastifies the \textit{static single-assignment}\cite{ssa} property.
A sea of nodes is an abstraction based on a directed graph structure which relate the control flow graph\cite{allen:ctrl-flow-analysis} of the program to its data flow graph\cite{allen:data-flow-analysis}.
An intermediate representation is in single-static assignment form when each variable is declared once and every use of a variable occurs immediately after its declaration\cite{johnson:use-def-chains}.


GraalIR enables Graal to speculatively compile only the \textit{hot} branches\cite{graalvm:speculative-ir}, or branches that are most frequently taken, in the control flow portion of the IR and their transitive data dependencies.
When a compiled program enters an unexpected state, execution is \textit{deoptimized}\cite{self:deoptimization} and control of the program is transferred back to the interpreter.
Deoptimization occurs when the compiled program is no longer considered stable and therefore is invalid.
Graal automatically inserts \textit{guard nodes} into the IR, which are conditional checks which validate that speculative assumptions used to compile the program still hold.
Deoptimization is part of an execution loop between Graal and Truffle which allows GraalVM to aggressively adapt and speculate to find the best optimization in a dynamic environment.

\smartdiagramset{
	text width=2.75cm,
	uniform color list=white for 3 items,
	uniform arrow color=true,
	arrow color=black,
}
\begin{figure}[!htb]
	\centering
	\scalebox{0.7}{
		\smartdiagram[circular diagram:clockwise]{
			Node rewriting,
			Partial evaluation,
			Deoptimization
	}}
	\caption{Adaptive optimization loop of GraalVM}
\end{figure}

\subsection{Truffle}

Truffle is a \acrfull{dsl} framework for guest language implementation embedded in GraalVM.
A guest language is a language which is expected to run on Graal and requires an implementation in the \textit{host language}, which provides the Truffle DSL.
In this thesis, the guest language is TASTy (which represents Scala) and the host language is Java, the implementation language of Truffle.
A guest language implementation always takes the form of an executable Truffle AST.

During execution of the AST, profiling information collected from the interpreter is used to drive \textit{node rewriting}.
While Graal is language-agnostic, Truffle is able exploit guest language semantics for dynamic optimizations.
This process of replacing nodes in the AST with better, specialized guest language counterparts in Truffle is called node rewriting.
Node rewriting serves two purposes.
The first is to dynamically incorporate guest language semantics into the executing program.
The second is to augment the AST for JIT compilation. 
In this thesis, we will focus heavily on node rewriting the execution of TASTy trees in a Truffle interpreter to augment JIT compilation.

\begin{figure}[!htb]
	\begin{minted}{scala}
	abstract class EqualsNode extends BinaryOpNode {
		@Specialization
		def equalsInt(lhs: Int, rhs: Int): Boolean = lhs == rhs
		
		@Specialization(replaces="equalsInt")
		def equals(lhs: Any, rhs: Any): Boolean = if (lhs == null) rhs == null else lhs.equals(rhs)
	}
	\end{minted}
	\caption{Pseudocode for a Truffle node implementation of an equality which supports node rewriting.}
	\label{example:node-rewriting}
\end{figure}

Figure \ref{example:node-rewriting} demonstrates an example of a node which can be rewritten.
The node declares semantics of the equality operation between integers and values of type \scalainline{Any}.
This equality node has semantics for every type because the \scalainline{Any} type is the super type of all types in Scala .
A Truffle node which can be rewritten starts off in the uninitialized state.
When both the left and right hand side operands are integers, the node is rewritten to \javainline{equalsInt}.
When arguments of any other combination of types are detected, either in the uninitialized state or the \javainline{equalsInt} state, the node is rewritten to the \javainline{equals} state.

After node rewriting, Graal JIT compiles Truffle ASTs into native machine code using \textit{partial evaluation}.
Partial evaluation is a program optimization technique for specializing an a program (code) for a given input (data)\cite{futamura:partial-eval}.
In the context of Truffle, this means combining a method (code) with a sequence of arguments (data)\cite{truffle:partial-eval}.
When a Truffle AST is submitted for compilation to Graal, it is considered \textit{stable}, or no longer suitable for node rewriting.
These previously dynamic arguments can now be considered static data in the method itself.
We can say that the partial evaluation of a method with a set of arguments will produce a specialized method that always execute with those arguments.
