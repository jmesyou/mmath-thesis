\chapter{Background}

In this chapter, we will provide an introduction to the Scala programming language. 
We will showcase a running example that we will use for the remainder of this thesis which exhibits features commonly present in Scala programs. 
We will describe \acrfull{tasty}, an intermediate storage format used for separate compilation\cite{???} of Scala programs. 
We will introduce a critical transformation, type erasure, which alters Scala programs so that they may executable on their default platform the \acrfull{jvm}. 
We will detail GraalVM \acrfull{jit} compiler infrastructure, an alternative JVM implementation which we use to implement a runtime for Scala in this thesis.

\section{Scala}

Scala\cite{scala:overview} is an objected-oriented, generic and statically typed programming language.
Scala uses a \textit{pure} object-oriected programming model\cite{smalltalk:design} and addresses many of the shortcomings\cite{go4:design-patterns} in other object-oriented programming languages.
Scala can be still considered \textit{Java-like} because of the interoperability between Java and Scala programs.
Programs in Scala may contain generic definitions, allowing Scala programs to be composable and reusable\cite{scala:origins}.
While these features offer abstractions which facilitate the design of increasingly complex programs, there are significant challenges with their implementation.
In the subsequent sections of this chapter, we will describe the challenges implementing these paradigms when manifested in the various intermediate representations of Scala.
We first begin with an explanation of the relevant programming paradigms present in Scala:

\begin{description}
	\item[Object-oriented] 
	Every value in Scala is an object and every operation is method invocation on an object. 
	Every object in Scala is an instance of a \textit{class} and their type is determined by its class.
	Classes\cite{simula:classes} are a mechanism for defining state and behaviour for a group of objects.	
	
	\item[Generic] 
	Classes in Scala may contain \textit{type parameters} and such classes can be considered \textit{polymorphic}\cite{strachey:fundamental-concepts}.
	Polymorphic classes may define behavior independent of their data, allowing them to be reused extensively for multiple types of data.
	In this thesis, we will interchangeably use the term \textit{parametric polymorphism} to refer to generics.
	
	\item[Statically typed] 
	Static typing is a discipline where the type information about a program is known \textit{before} it is executed.
	In order for a Scala program to compile successfully, it must be \textit{well-typed}.
	For our purposes, computation should always produce a value which has a type matching the type declared by the programmer to be considered well-typed.
	Classes are the primary syntactical mechanism for declaring types in Scala. 
	The properties of classes such as state, in the form of fields, and behaviour, in the form of methods, must be well-typed.
	Similarly, the uses of these properties in other classes must also be well-typed. 
\end{description}

\section{Case Study: A List in Scala}

In this section, we will introduce the running example that will be used for the remainder of this thesis and our motivations for its selection.
Figures \ref{example:list-def}, \ref{example:cons-impl} and \ref{example:nil-impl} contain an abstract singly-linked list class and its two concrete subclass implementations. 
This set of \scalainline{List} implementations represent probable real-world use cases as they are a scaled down and simplified version of the list implementation present in the Scala collections library.
The \scalainline{List} definition from the collections library is available by default to all Scala programs.

\begin{figure}[!htb]
	\begin{minted}{scala}
	abstract class List[+T] {
		def head: T
		def tail: List[T]
		def length: Int
		def isEmpty: Boolean = length == 0
		def contains[T1 >: T](elem: T1): Boolean
	}
	\end{minted}
	\caption{Definition of \texttt{List} class}
	\label{example:list-def}
\end{figure}

Figure \ref{example:list-def} is an example which showcases the paradigms discussed in the previous section that are also commonly present real-world Scala programs.
Implementations which extend the abstract \scalainline{List} class exhibit the object-oriented property of \textit{inheritance}.
The \scalainline{List} class contains a mixture of polymorphic and non-polymorphic methods to showcase type specialization
The \scalainline{head} method is class-polymorphic in that its type is derived from a class parameter and becomes specialized when the class is specialized.
The \scalainline{contains} method is method-polymorphic and must be specialized after the class is specialized.

\begin{figure}[!htb]
	\begin{minted}{scala}
	case class Cons[+T](head: T, tail: List[T]) extends List[T] {
		override def length: Int = 1 + tail.length
		
		override def contains[T1 >: T](elem: T1): Boolean = {
			var these: List[T] = this
			while (!these.isEmpty) 
				if (these.head == elem) return true
				else these = these.tail
			false
		}
			
		override def hashCode(): Int = {
			var these: List[T] = this
			var hashCode: Int = 0
			while (!these.isEmpty) {
				val headHash = these.head.## // Compute hashcode
				if (these.tail.isEmpty) hashCode = hashCode | headHash
				else hashCode = hashCode | headHash >> 8
				these = these.tail
			}
			hashCode
		}
	}
	\end{minted}
	\caption{Implementation of \texttt{Cons} class}
	\label{example:cons-impl}
\end{figure}

Figure \ref{example:cons-impl} contains the implementation of a list node.
The \scalainline{Cons} implementation contains two polymorphic fields, \scalainline{head} and \scalainline{tail}.
For specialization, how the \scalainline{head} field fits into the storage layout of a \scalainline{Cons} instance may differ between a \scalainline{Cons[Int]} and a \scalainline{Cons[String]}.
On the other hand, the \scalainline{tail} field does not have to differ between instances of \scalainline{Cons[Int]} and \scalainline{Cons[String]}.

\begin{figure}[!htb]
	\begin{minted}{scala}
	case object Nil extends List[Nothing] {
		override def head: Nothing = throw new NoSuchElementException("head of empty list")
		override def tail: Nothing = throw new UnsupportedOperationException("tail of empty list")
		override def length: Int = 0
		override def contains[T1 >: Nothing](elem: T1): Boolean = false
		override def hashCode(): Int = 0
	}
	\end{minted}
	\caption{Implementation of \texttt{Nil} class}
	\label{example:nil-impl}
\end{figure}

Figure \ref{example:nil-impl} contains the implementation of the empty list. 
We provide the implementation of this class for completeness.


\section{Typed Abstract Syntax Trees}

An \acrfull{ir} is a structural abstraction representing a program during compilation or execution. 
Intermediate representations are more suitable for reasoning about a program than program source code. 
\acrshort{ir} can be used for compilation\cite{llvm}, optimization\cite{llvm}\cite{ssa}, or execution\cite{java:vm-spec}\cite{clr:spec}.

\acrfull{tasty} is a high-level \acrfull{ir} which is produced and emitted after the type checking phase (also called the typer) of the Scala compiler (see appendix \ref{appendix:dotty-phases}).
Figure \ref{system:tasty} gives an overview of TASTy generation in the context of the Scala compilation pipeline, note that TASTy is only generated for Scala program sources.
TASTy is a well-typed variation of an \acrfull{ast}.
Abstract syntax trees are a commonly used intermediate representation which resemble the program source representation.
TASty can be considered a \textit{complete} IR of a Scala program before compilation, unlike the other intermediate representations we will examine throughout this thesis.
A complete IR is able to capture all information of the original Scala source program.
We will expand on why complete intermediate represenations are significant in section \ref{background:type-erasure}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\textwidth]{figures/scala-pipeline.png}
	\caption{TASTy in the context of the Scala compilation pipeline.}
	\label{system:tasty}
\end{figure}

The full TASTy IR can represent all Scala programs.
The Truffle interpreter in this thesis supports a subset sufficient to express the the programs given in figures \ref{example:list-def} and \ref{example:list-impl}.
The TASTy trees used in this thesis can be divided into categories, definitions, terms, and types. 
We give the pseudo implementations of these trees in figures: \ref{tasty:defs}, \ref{tasty:terms}, and \ref{tasty:types}.

\subsection{Definitions}

\begin{figure}[!htb]
	\begin{minted}{scala}
	// Tree representing code written in the source
	trait Tree {
		def symbol: Symbol
	}                         
	trait Statement extends Tree       // Tree representing a statement in the source code
	trait Definition extends Statement // Tree representing a definition in the source code.
		
	// Tree representing a class definition.
	case class ClassDef(
		name:        String,
		constructor: DefDef, 
		parents:     List[Tree], 
		self:        Option[ValDef], 
		body:        List[Statement]
	) extends Definition
	// Tree representing a method definition in the source code
	case class DefDef(
		name:      String, 
		params:    List[ParamClause], 
		returnTpt: TypeTree, 
		rhs:       Option[Term]
	) extends Definition
	// Tree representing a value definition in the source code.
	case class ValDef(name: String, tpt: TypeTree, rhs: Option[Term]) extends Definition
	// Tree representing a type (parameter or member) definition in the source code
	case class TypeDef(name: String, rhs: Tree) extends Definition
	\end{minted} 
	\caption{Pseudocode class definitions for a subset of TASTy trees.}
	\label{tasty:defs}
\end{figure}

A Scala program consists of top level class definition which themselves contain statements.
Statements either represent a declaration inside a class, such as method definitions, or executable code (or terms), which we discuss in section \ref{section:tasty:terms}.
Figure \ref{tasty:defs} provides the pseudo implementations of all definitions in our subset of TASTy.
Every tree has a symbol, which is a unique reference to a definition.
For the use cases in this thesis, most definitions can be translated and be represented by a corresponding implementation in Truffle.
A \scalainline{ClassDef} represents a top level class definition.
A \scalainline{DefDef} tree is the definition of a method inside a class definition.

A \scalainline{ValDef} tree is a context-dependent definition which represents different value definition semantics depending on the tree it is defined in.
A top level \scalainline{ValDef}, that is a \scalainline{ValDef} with no parent represents the \scalainline{object} abstraction in Scala.
The \scalainline{object} abstraction is commonly used to represent the \textit{Singleton} pattern\cite{go4:design-patterns} or as a class-like interface to define static methods.
Consider the \scalainline{Nil} class given in figure \ref{example:nil-impl}, a simplified TASTy-like equivalent would resemble the following:

\begin{figure}[!htb]
	\begin{minted}{scala}
	val Nil = new Nil$
	class Nil$ extends List[Nothing] { ... }
	\end{minted} 
	\caption{Simplified implementation of the \scalainline{object Nil}}
	\label{example:decomp-object}
\end{figure}

A \scalainline{ValDef} tree defined in the \scalainline{body} of a \scalainline{ClassDef} tree represent field definitions.
A \scalainline{ValDef} tree defined in the \scalainline{TermParam} section of a \scalainline{DefDef} tree represent parameter definitions of the method.
A \scalainline{ValDef} tree defined among the statements in a \scalainline{Block} tree is a local variable definition limited to the scope of the block.

Similarly, \scalainline{TypeDef} trees refer to different kinds of definitions depending on their definition site.
A \scalainline{TypeDef} in the body of a \scalainline{ClassDef} refers to a polymorphic class type parameter in our subset of TASTy.
When a \scalainline{TypeDef} is located in the \scalainline{TypeParam} section a \scalainline{DefDef} tree, it refers to a polymorphic method type parameter.
The trees defined here can be used to represent more complex object-oriented and functional abstractions such as nested classes or closures, but they are beyond the scope of this thesis.

Figure \ref{tasty:list} is the TASTy structure of the \scalainline{List} class given in figure \ref{example:list-def}. 
Recall that \scalainline{ClassDef} trees have four structural components, the constructor, the list of parent class definitions, the self type, and the body of the definition.
In this thesis, we will not discuss the self type as it is an abstraction for composition\cite{gilad:mixins}\cite{scala:calculus} and is not relevant for execution.
The list of parents in a class definition in our subset of TASTy is always a singleton.
Note that while the abstract \scalainline{List} class did not explicitly declare a constructor, the compiler autogenerates and inserts the appropriate constructor implementation before emitting TASTy.
Since \scalainline{List} is polymorphic, it contains an inner type definition of its sole type parameter.
This distinction is what makes TASTy a complete IR when compared to the other intermediate representations we will describe later in this chapter.

\begin{figure}[!htb]
	\begin{minted}{scala}
	ClassDef(
		// name 
		"List",
		// constructor
		DefDef("<init>", List(TypeParams(TypeDef("T", TypeBoundsTree(_, _)), TermParams(Nil)), _, None)),
		// parents
		List(Apply(Select(New(_, "<init>"), Nil))),
		// self
		None,
		// body
		List(
			TypeDef("T", TypeBoundsTree(_, _)),
			DefDef("head", Nil, TypeIdent("T"), None),
			DefDef("tail", Nil,Applied(TypeIdent("List"), List(TypeIdent("T"))),None),
			DefDef("length", Nil, TypeIdent("Int"), None),
			DefDef("isEmpty", Nil, TypeIdent("Boolean"), None),
			DefDef(
				"contains",
				List(
					TypeParams(TypeDef("T1", TypeBoundsTree(TypeIdent("T"), _))),
					TermParams(ValDef("elem", TypeIdent("T1"), None))
				),
				TypeIdent("Boolean"),
				None
			)
		)
	)
	\end{minted} 
	\caption{Tree structure for the definition of \texttt{List} . For brevity, we use \textbf{\texttt{\_}} to represent inferred\cite{ml:type-inference} type trees by the compiler.}
	\label{tasty:list}
\end{figure}

Similarly, \scalainline{DefDef} trees also retain their polymorphic properties.
The parameters section of a \scalainline{DefDef} tree is split into two halves.
The type parameter section preserves any polymorphic type parameters in the method definition.
The term parameter section contains the normal value parameters found in a method.
Term parameters may have types which are derived from the type parameter section.

\subsection{Terms}
\label{section:tasty:terms}

\begin{figure}[!htb]
	\begin{minted}{scala}
	// Tree representing an expression in the source code
	trait Term extends Statement {
		def tpe: Type
	}
	// Tree representing a reference to definition      
	trait Ref extends Term             
	
	// Tree representing an assignment lhs = rhs in the source code
	case class Assign(lhs: Term, rhs: Term) extends Term
	// Tree representing new in the source code
	case class New(tpt: TypeTree) extends Term
	// Tree representing a block `{ ... }` in the source code
	case class Block(statements: List[Statement], expr: Term) extends Term
	// Tree representing a while loop
	case class While(cond: Term, body: Term) extends Term
	// Tree representing an if/then/else if (...) ... else ... in the source code
	case class If(cond: Term, thenp: Term, elsep: Term) extends Term
	// Tree representing a return in the source code
	case class Return(expr: Term, from: Symbol) extends Term
	// Tree representing a selection of definition with a given name on a given prefix
	case class Select(qualifier: Term, selector: String) extends Term 
	// Tree representing an application of arguments.
	case class Apply(applicator: Term, arguments: List[Term]) extends Term
	// Tree representing an application of type arguments
	case class TypeApply(fun: Term, args: List[TypeTree]) extends Term
	// Tree representing a reference to definition with a given name
	case class Ident(name: String) extends Ref 
	// Tree representing constant value
	case class Constant(value: Int | ... | String) extends Term 
	\end{minted} 
	\caption{Pseudocode class definitions for a subset of TASTy trees.}
	\label{tasty:terms}
\end{figure}

Figure \ref{tasty:terms} gives the implementation for terms in our subset of TASTy.
Terms represent executable atoms of code which return values.
Terms can be considered analogous to expressions from the abstract syntax trees commonly used for other imperative programming languages.
Our term tree subset of TASTy represents a basic language with support for simple imperative programming with control flow constructs such as branching and loops.
A basic set of object-oriented features are also encapsulated in the tree definitions given above.
The set of object-oriented features include object creation, instance method invocation, and instance field access.
This subset of TASTY is sufficient to represent the creation of polymorphic classes as well as the invocation of polymorphic methods to showcase the examples described in this thesis.

Terms in TASTy also retain their types after type checking by the Scala compiler.
A type for a term describes the type of the value produced by the term.
Terms with no children, such as \scalainline{Ident} trees, are \textit{explicit} typed.
Childrenless terms have their type information encoded in a TASTy file.  
For terms with children, their types are derived from those of their children trees.
Type information for non-leaf term trees is regenerated from term leaves when a TASTy file is read.
In essence, types `flow' upwards from leaf nodes in TASTy to their parent terms until the root term.
The interpreter described in this thesis intreprets a tree where the types for all trees have been regenerated.
We will describe types in detail in the following section.

\subsection{Types and Type Trees}

TASTy encodes Scala programs with two kinds of type information, type trees and types.
Type trees are a subset of trees which represent types as they are declared in Scala source code.
On the other hand, types are the canonical representation of type trees after type checking in the Scala compiler.
Multiple type trees may denote the same underlying type.

\begin{figure}[!htb]
	\begin{minted}{scala}
	// Type tree representing a type written in the source
	trait TypeTree extends Tree {
		def tpe: Type
	}
	
	// Type tree representing a reference to definition with a given name
	case class TypeIdent(name: String) extends TypeTree 
	// Type tree representing a type application
	case class Applied(tpt: TypeTree, args: List[TypeTree | TypeBoundsTree]) extends TypeTree
	// Type tree representing a type bound written in the source
	case class TypeBoundsTree(lo: TypeTree, hi: TypeTree) extends TypeTree
	\end{minted} 
	\caption{Pseudocode class definitions for a subset of TASTy type trees.}
	\label{tasty:type-trees}
\end{figure}

Figure \ref{tasty:type-trees} gives the subset of type trees which we will use in this thesis.
For our purposes, there are only three ways to refer to types.
A \scalainline{TypeIdent} type tree is a reference to a type which is a \scalainline{ClassDef}.
An \scalainline{Applied} type tree represents a type constructor, which accepts type arguments and produces a new type.
For example, the type \scalainline{Cons[T]} would be represented as an applied type tree, where \scalainline{Cons} would the constructor and \scalainline{T} would be the type argument.
A \scalainline{TypeBounds} tree represents the type expression \scalainline{Lo <: T <: Hi}, a constraint where \scalainline{T} must be a subtype of type \scalainline{Hi} and supertype of type \scalainline{Lo}.
Type bounds are typically used to represent declared type parameter constraints, otherwise known as \textit{bounded quantification}\cite{systemF:subtyping}, in polymorphic classes or polymorphic methods.
However, type bounds are also inserted by the Typer because type parameters in TASTy are universally contraints.
A type parameter \scalainline{T} is expanded to \scalainline{Nothing <: T <: Any}, that is the type parameter \scalainline{T} must be a subtype of \scalainline{Any} and a supertype of \scalainline{Nothing}.
In the context of this thesis, we can use subtype to mean \textit{subclass of} and supertype to mean \textit{superclass of}.
Practically, this means the type parameter \scalainline{T} has no constraints since \scalainline{Any} is the super type of all types and \scalainline{Nothing} is the subtype of all types.

\begin{figure}[!htb]
	\begin{minted}{scala}
	trait Type                           // A type, type constructors, type bounds
	trait NamedType extends Type         // Type of a reference to a type or term symbol
	case class TypeRef extends NamedType // Type of a reference to a type symbol
	case class AppliedType extends Type  // A higher kinded type applied to some types T[U]
	case class TypeBounds extends Type   // Type bounds
	\end{minted} 
	\caption{Pseudocode class definitions for a subset of TASTy type trees.}
	\label{tasty:types}
\end{figure}

Figure \ref{tasty:types} is set of types used in our subset of TASTy.
In most cases in our subset of TASTy, the type trees have a corresponding type of the same name.
However, the \scalainline{NamedType} does not appear in type trees as they are predominantly used to type terms.
The \scalainline{TypeRef} type is a reference to a \scalainline{ClassDef} tree or a type parameter \scalainline{TypeDef}.

In the Scala compilation pipeline, TASTy is eventually simplified and transformed by the Scala compiler to produce Java bytecode. 
In chapter \ref{chapter:implementation}, We will go over each tree before such transformations and their relevance for execution in our interpreter .

\section{Java Bytecode}

Java bytecode is a portable and compact intermediate language and instruction set used by the Java Virtual Machine to execute programs.
Java bytecode can be considered similar to an assembly language, where programs are represented as sequences of atomic instructions which manipulate a stack or registers.
The type system in Java bytecode can describe primitive values such as \javainline{int} and references to objects such as \javainline{String}.
As bytecode is intended to be simple for execution, it is not possible to represent polymorphic programs fully in Java bytecode.

Types in TASTy are not immediately compatible with types available in Java bytecode.
Scala's type semantics must be eliminated from programs by the compiler before Java bytecode of the program can be emitted.
The resulting Java bytecode is considered an \textit{incomplete} IR of Scala source programs, as the type information found in the program source or inferred from compilation is no longer present.
This becomes a particular drawback for executing Scala programs on the JVM because speculative optimizations are unable to incorporate source level semantics.

\begin{figure}[!htb]
	\begin{minted}{scala}
	aload_0
 	astore_2
	aload_2
	invokevirtual #44 // List.isEmpty:()Z
	ifne          30
	aload_2
	invokevirtual #46 // List.head:()Ljava/lang/Object;
	aload_1
	invokestatic  #52 // Method scala/runtime/BoxesRunTime.equals:(Ljava/lang/Object;Ljava/lang/Object;)Z
	ifeq          22
	iconst_1
	ireturn
	aload_2
	invokevirtual #53 // List.tail:()LList;
	astore_2
	goto          2
	iconst_0
	ireturn
	\end{minted}
	\caption{Java bytecode of \texttt{Cons.contains}}
	\label{example:contains-bytecode}
\end{figure}

Figure \ref{example:contains-bytecode} is the Java bytecode of the \scalainline{contains} defined at line 4 in figure \ref{example:cons-impl}.
Typical control flow elements of Scala programs such as if terms and while terms have been converted into branch and jump instructions.
Notice that there are no polymorphic type parameters in the description of classes nor in the invocation of polymorphic methods present in the bytecode.
In particular, notice the equality comparison in line 7 of figure \ref{example:cons-impl} is actually a method invocation (instruction 14 in figure \ref{example:contains-bytecode}).
As the Scala compiler is unable to determine the type of a polymorphic type parameter during complilation time, it is unable to select a Java bytecode instruction which implements polymorphic comparison.
Instead, a bridge method part of the Scala standard library is responsible for handling polymorphic operations which operate on both reference and primitive types during runtime.
In the next section, we describe the process which transforms Scala programs to a reprensentation amenable for Java bytecode generation and the necessary additional runtime overhead associated with this transformation.

\section{Type Erasure}
\label{background:type-erasure}

Type erasure\cite{java:generics} is a transformation which converts polymorphic classes and methods in Scala to monomorphic classes and methods. 
This conversion is necessary because the JVM does not support polymorphic classes during runtime.
Erasure ensures that any given polymorphic class and method has a single representation in practice.
Type erasure is a crucial part of Scala compilation that renders TASTy incomplete.
Figure \ref{example:erase-cons} shows the \scalainline{Cons} class after type erasure.

\begin{figure}[!htb]
	\begin{minted}{scala}
	case class Cons(head: Any, tail: List) extends List {
		override def length: Int = 1 + tail.length
			
		override def contains(elem: Any): Boolean = {
			var these: List = this
			while (!these.isEmpty) 
			if (these.head == elem) return true
			else these = these.tail
			false
		}
			
		override def hashCode(): Int = {
			var these: List = this
			var hashCode: Int = 0
			while (!these.isEmpty) {
				val headHash = these.head.##
				if (these.tail.isEmpty) hashCode ||= headHash
				else hashCode |= headHash >> 8
				these = these.tail	
			}
			hashCode
		}
	}		
	\end{minted}
	\caption{\scalainline{Cons} class after type erasure}
	\label{example:erase-cons}
\end{figure}

The polymorphic \scalainline{Cons} class has all type parameters in its class definition \textit{erased} and replaced by the \scalainline{Any} type.
The \scalainline{Any} type is a Scala platform-independent\cite{scala:overview} abstract type representing the supertype of primitive and reference types.
In Java bytecode, the {Any} type is compiled to the \scalainline{Object} type, the supertype of all reference types on the JVM.

While type erasure simplifies classes for runtime, the Scala compiler must resolve the incompatibility of operations between primitives types and reference types on the JVM\cite{java:vm-spec}.
In order for primitive types to have a uniform representation compatible with reference types, primitive types are encapsulated into corresponding boxed classes whose objects are passed by reference.
For example, \javainline{java.lang.Integer} is a class with an \scalainline{Int} field.
In a polymorphic context in which a type variable has been replaced by the reference type \javainline{Object}, an \scalainline{Int} value is not passed directly, but by reference to an object of class \javainline{Integer} that contains the primitive value.
The set of operations introduced by the compiler whenever a primitive value is accessed under a polymorphic context is known as \textit{autoboxing}\cite{java:autoboxing}. 
Autoboxing can be divided into two operations.
\textit{Boxing} occurs when a primitive value must be used where a polymorphic value is expected.
\textit{Unboxing} occurs when a polymorphic value must be used where a primitive value is expected.
Figure \ref{example:autoboxing} shows a simple example of inserted autoboxing operations when using the polymorphic \scalainline{Cons} class after type erasure.

\begin{figure}[!htb]
	\begin{minted}{scala}
	// Before type erasure 	
	val lst: List[Int] = Cons(1, Nil)
	val head: Int = lst.head
	// After type erasure
	val lst: List = Cons(box(1), Nil)
	val head: Int = unbox(lst.head) 
	\end{minted}
	\caption{Example of autoboxing introduced for a list}
	\label{example:autoboxing}
\end{figure}

The \scalainline{head0} field inside the \scalainline{Cons} class after erasure is no longer polymorphic and instead has the type \scalainline{Any}. 
The integer value of \scalainline{1} which is passed into the class constructor for the list is boxed and the primitive value is wrapped as an instance of its boxed class.
Similarly, when the \scalainline{head0} field of the instance is read and stored into a local variable, an unboxing operation occurs which extracts the primitive value out of its wrapper instance.
In the Scala collections library, a set of commonly used polymorphic data structures, autoboxing operations are frequent and necessary.
The computational overheads of autoboxing operations on programs which make substantial use of polymorphic collections, especially the Scala standard library, is significant\cite{scala:collections-optimization}.
The elimination of this overhead through optimizing autoboxing operations is one of the central goals of this thesis.
In addition to this direct overhead, autoboxing is a significant indirect source of overhead which makes the analysis of programs using primitive values in a polymorphic context and thus inhibits many significant compiler optimizations.

\section{GraalVM}

GraalVM\cite{java:graalvm} is an implementation of a JVM.
Traditionally, the JVM is responsible for the majority of the performance optimizations in Java programs\cite{java:hotspot} through \acrfull{jit} compilation.
JIT compilation is an adaptive optimization which occurs during program execution.
JIT compilation is concerned with optimizing and eliminating \textit{hotspots} or portions of the program which are executed most frequently.
JIT compilers\cite{java:sablevm}\cite{java:jikesrvm} employ a range of \textit{speculative} techniques to transform the program under optimization.
Speculative optimizations use information collected during program execution, otherwise known as \textit{profiling}. 
Assumptions are then made about gathered profiling data in order to generate high-performance native machine code.
A key aspect of speculative optimizations using assumptions is that optimizations may be undone when their underlying assumptions are violated.
This enables the JIT compiler to optimize programs without the need to statically prove assumptions hold in every execution path.

While other implementations of Java virtual machines were designed specifically for Java, GraalVM was designed from the onset to be \textit{language-independent}.
GraalVM can be divided into two major components of interest. 
The first is \textit{Graal}, a language-agnostic JIT compilation infrastructure which handles speculative optimizations and generation of high-performance machine code.
The second is \textit{Truffle}, a framework for translating the semantics of a source language, also called a \textit{guest language}, to take advantage of the Graal infrastrucure.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.5\textwidth]{figures/graalvm-pipeline.png}
	\caption{GraalVM overview\cite{graalvm:ir}.}
\end{figure}

This thesis makes substantial of both components of GraalVM to create a runtime for Scala programs using TASTy.
The runtime is able to incorporate source level information for speculative optimizations.


\subsection{Graal}

GraalVM incorporates an existing implementation of a JVM\cite{java:hotspot} for the actual execution of programs.
Graal is \textit{only} the general-purpose just-in-time compilation infrastructure which optimizes the programs to be executed.
Graal is general-purpose in that it conducts analysis and optimization on the same intermediate representation, \textit{Graal IR}, regardless of the original source language.
Notably, most implementations of a source language utilizing GraalVM have an implementation in Truffle, Java is an exceptional case.
In addition to a Truffle interpreter for Java bytecode\cite{graalvm:espresso}, there is a direct translator for Java programs in GraalVM which parses Java bytecode into Graal IR.

Graal IR\cite{graalvm:ir}\footnote{Given the number of intermediate representations introduced thus far, we promise this is the last one} is an IR which is suitable for speculative optimizations while still retaining information from the Truffle guest language AST.
Graal IR is based on the \textit{sea of nodes} concept\cite{click:sea-of-nodes} and satisfies the \textit{static single-assignment}\cite{ssa} property.
A sea of nodes is an abstraction based on a directed graph structure which relates the control flow graph\cite{allen:ctrl-flow-analysis} of a program to its data flow graph\cite{allen:data-flow-analysis}.
An intermediate representation is in single-static assignment form when each variable is declared once and every use of a variable occurs immediately after its declaration\cite{johnson:use-def-chains}.

GraalIR enables Graal to speculatively compile only the \textit{hot} branches\cite{graalvm:speculative-ir}, or branches that are most frequently taken, in the control flow portion of the IR and their transitive data dependencies.
When a compiled program violates any of its underlying assumptions, execution is \textit{deoptimized}\cite{self:deoptimization} and the program resumes execution in its uncompiled format.
Deoptimization occurs when the compiled program is no longer considered stable and therefore is invalid.
Graal automatically inserts \textit{guard nodes} into the IR, which are conditional checks which validate that speculative assumptions used to compile the program still hold.
Deoptimization is part of an execution loop between Graal and Truffle which allows GraalVM to aggressively adapt and speculate to find the best optimization in a dynamic execution environment.

\smartdiagramset{
	text width=2.75cm,
	uniform color list=white for 3 items,
	uniform arrow color=true,
	arrow color=black,
}
\begin{figure}[!htb]
	\centering
	\scalebox{0.7}{
		\smartdiagram[circular diagram:clockwise]{
			Node rewriting,
			Partial evaluation,
			Deoptimization
	}}
	\caption{Adaptive optimization loop of GraalVM}
	\label{diagram:graal-loop}
\end{figure}

\subsection{Truffle}

Truffle is a framework for implementing an interpreter embedded into GraalVM.
Truffle differs signficantly from other implementations of interpreters.
Interpreters can usually be divided into two subsets: tree interpreters and bytecode interpreters.
Tree interpreters transform program source into an abstract syntax tree which is then executed in post-order, children nodes are executed before their parents.
Abstract syntax tree interpretation has the added benefit of executing an intermediate representation which is quite close to the program source representation and is therefore more amenable to program optimization.
In contrast, bytecode interpreters such as the JVM, execute a vastly simplified representation of programs.
While interpreters of bytecode programs tend to be faster than their tree counterparts, the absence of detailed source information such as types often makes program optimization difficult.
The challenge of efficiently executing bytecode while retaining the ability to optimize them effectively using source program information is particularly difficult for Scala on the JVM. 

\begin{figure}[!htb]
	\begin{minted}{scala}
	abstract class EqualsNode extends BinaryOpNode {
		@Specialization
		def equalsInt(lhs: Int, rhs: Int): Boolean = lhs == rhs
		
		@Specialization(replaces="equalsInt")
		def equals(lhs: Any, rhs: Any): Boolean = if (lhs == null) rhs == null else lhs.equals(rhs)
	}
	\end{minted}
	\caption{Pseudocode for a Truffle node implementation of an equality which supports node rewriting.}
	\label{example:node-rewriting}
\end{figure}

Truffle is an atypical tree interpreter in that it combines the definition, execution, and optimization of an abstract syntax tree structure into a single abstraction.
While the structure of input programs in other interpreters is independent of the implemenation of the interpreter, a Truffle interpreter is integrated into the structure of its input.
By defining execution semantics inside the abstract syntax tree to be executed, an interpreter is essentially derived from the implementation of its input tree structure.
The execution semantics of the AST are additionally augmented with the Truffle \acrfull{dsl}, which allows such trees to be \textit{self-optimizing}.
The Truffle DSL is a mechanism to allow a \textit{guest language} to embed semantics into a Truffle AST for optimization.
A guest language is a set of semantics, most commonly a programming language, which is described by a Truffle AST.
In this thesis, the guest language which our Truffle AST encodes and executes is TASTy (which represents Scala).

\begin{figure}[!htb]
\begin{minted}{java}
	@GeneratedBy(AnyEqNode.class)
	public final class AnyEqNodeGen extends AnyEqNode {
		@Child
		private TermNode lhs_;
		@Child
		private TermNode rhs_;
		@CompilationFinal
		private int state_0_;
		
		private AnyEqNodeGen(TermNode lhs, TermNode rhs) {
			this.lhs_ = lhs;
			this.rhs_ = rhs;
		}
		
		public Object execute(VirtualFrame frame) {
			int state = this.state_0_;
			return (state & 2) == 0 && state != 0 ? 
				this.execute_int_int0(state, frame) : 
				this.execute_generic1(state, frame);
		}
\end{minted}
\end{figure}

During execution of the AST, profiling information collected from the interpreter is used to drive \textit{node rewriting}.
While Graal is language-agnostic, Truffle is able to exploit guest language semantics for dynamic optimizations.
This process of replacing nodes in the AST with better, specialized guest language counterparts in Truffle is called node rewriting.
Node rewriting makes Truffle abstract syntax trees self-optimizing and serves two purposes.
The first is to dynamically incorporate guest language semantics into the executing program.
The second is to augment the AST for more efficient JIT compilation.
The nature of compiler optimizations require that programs are incrementally simplified in order to be optimized.
While such types of optimizations are widely applicable to many languages using the JVM, node rewriting is a high-level language-specific optimization which occurs \textit{before} such simplifications.

Figure \ref{example:node-rewriting} demonstrates an example of a node which can be rewritten.
The node declares semantics of the equality operation between integers and values of type \scalainline{Any}.
This equality node has semantics for every type because the \scalainline{Any} type is the super type of all types in Scala .
A Truffle node which can be rewritten starts off in the uninitialized state.
When both the left and right hand side operands are integers, the node is rewritten to \javainline{equalsInt} state.
When arguments of any other combination of types are detected, either in the uninitialized state or the \javainline{equalsInt} state, the node is rewritten to the \javainline{equals} state.

After node rewriting, Graal JIT compiles Truffle ASTs into native machine code using \textit{partial evaluation}.
Partial evaluation is a program optimization technique for specializing a program (code) for a given input (data)\cite{futamura:partial-eval}.
In the context of Truffle, this means specializing an AST node (code) based on the values (or types of values) produced by their children nodes (data)\cite{truffle:partial-eval}.
We can say that the partial evaluation of an AST  will produce an AST which is \textit{specialized} for a particular set of values, or more commonly in our case, a particular set of types.
If a frequently executed Truffle AST cannot be rewritten further, it is considered \textit{stable} for JIT compilation into native machine code.  
The sequence of optimizations given in figure \ref{diagram:graal-loop}, node rewriting, partial evaluation into machine code, and deoptimization is the advantage that a TASTy Truffle interpreter has over the traditional JVM bytecode interpreter for Scala.
Truffle allows for the incorporation of source-level type information into the just-in-time compilation loop.
In this thesis, we will focus heavily on using node rewrites in the execution of TASTy with type information to augment JIT compilation.

